import cv2
from detectron2.data import DatasetCatalog
import numpy as np
from torchvision.ops import nms

def load_inference_instances(image_files):
    """ Use all given files to make Detectron2 format list of dicts."""
    dataset_dicts = []
    for image_file in image_files:
        record = {"file_name": image_file}
        dataset_dicts.append(record)
    return dataset_dicts

def register_inference_instances(name, image_files):
    """ Register dataset to use for inference. 
    
    Only image file paths are used.
    
    Args:
        name: name of Dataset
        image_files: list of image_files
    """
    DatasetCatalog.register(name, lambda: load_inference_instances(image_files))

def nms_all_classes(instances, iou_thresh):
    """ Apply non-maximum suppression to inference instances regardless of class.
    
    Args:
        instances: instances from detectron2 model
        iou_thresh: threshold to use for nms
        
    returns resulting instances after nms is applied
    """
    valid_ind = nms(instances.pred_boxes.tensor, instances.scores, iou_thresh)
    instances.pred_boxes.tensor = instances.pred_boxes.tensor[valid_ind]
    instances.scores = instances.scores[valid_ind]
    instances.pred_classes = instances.pred_classes[valid_ind]
    
    return instances

def draw_detections(image, instances, min_score, colors, thickness=3, 
                    from_GPU=True, raw_image=True, marker = 'box'):
    """ Draw the bounding boxes in instances on the image.
    
    Args:
        image: image array
        instances: instances generated by detectron2 model that produces bboxes
        min_score: only draw markers with scores above this value
        colors: list of colors to draw each class
        thickness: thickness of bounding box or radius of dot
        from_GPU: if True, move data in instances to cpu before using
        raw_image: if True, convert image from format fed into model
        marker: type of marker to draw. If 'box', bounding boxes will be drawn. If 'dot', dots will be drawn at the center of bbox area.
    
    return image with bounding boxes or dots drawn on
    """
    if raw_image:
        image = image['image'].cpu().permute(1, 2, 0).numpy().astype(np.uint8)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    if from_GPU:
        detection_dict = instances.get_fields()
        pred_boxes = detection_dict['pred_boxes'].tensor.cpu().numpy()
        scores = detection_dict['scores'].cpu().numpy()
        pred_classes = detection_dict['pred_classes'].cpu().numpy()
        
    for box, box_type, score in zip(pred_boxes, pred_classes, scores):
        if score < min_score:
            continue
        box = box.astype(np.float32)
        color = colors[box_type]
        if marker == 'box':
            cv2.rectangle(image, 
                        (box[0], box[1]), (box[2], box[3]), 
                        color, thickness)
        if marker == 'dot':
            w = int(box[2] - box[0])
            h = int(box[3] - box[1])
            cx = int(box[1] + h/2)
            cy = int(box[0] + w/2)
            cv2.circle(image, (cy, cx), thickness, color, -1)
    if (marker != 'box') & (marker != 'dot'):
        print("Marker type is not valid. Must be \"box\" or \"dot\". No markers drawn.")
    return image